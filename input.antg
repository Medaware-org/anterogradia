@library "org.medaware.anterogradia.libs.LinearAlgebra" as la
@library "org.medaware.anterogradia.libs.ASCII" as ascii

validator vector {
    la.validate(str = __validator_value())
}

fun ray_direction <width: integer, height: integer, x: integer, y: integer> {
    `planePosition := la.v {
        add(left = mul(left = signflp(expr = 1), right = div(left = &`width, right = 2)), right = &`x)
        add(left = mul(left = signflp(expr = 1), right = div(left = &`height, right = 2)), right = &`y)
        1.0
    }
    `cameraOrigin := la.v { 0 0 0 }
    la.normalize(v = la.sub { &`planePosition &`cameraOrigin })
}

fun render_pixel <width: integer, height: integer, x: integer, y: integer> {
    `direction := la.mul(v = eval ray_direction(width = &`width, height = &`height, x = &`x, y = &`y), fac = 128)
    `offset := la.v { 128 128 128 }
    la.sum { &`direction &`offset }
}

fun ppm3_header <width: integer, height: integer> {
    sequence {
        "P3" ascii.endl()
        &`width " " &`height ascii.endl()
        "255" ascii.endl()
    }
}

fun render_all <width: integer, height: integer> {
    `data := eval ppm3_header(width = &`width, height = &`height)

    `x := 0
    while (&`x < &`width) {
        `y := 0
        while (&`y < &`height) {
            `color := eval render_pixel(width = &`width, height = &`height, x = &`x, y = &`y)
            `r := trunc(expr = la.x(v = &`color))
            `g := trunc(expr = la.y(v = &`color))
            `b := trunc(expr = la.z(v = &`color))
            `data := sequence { &`data &`r " " &`g " " &`b ascii.endl() }
            increment (id = `y)
        }
        increment (id = `x)
    }

    &`data
}

eval render_all(width = 100, height = 100)
la.dot(a = la.v { 1 1 1 }, b = la.v { 3 2 1 })